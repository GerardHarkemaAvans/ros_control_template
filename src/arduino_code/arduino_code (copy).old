#include <ros.h>
#include <std_msgs/Float32MultiArray.h>
#define encodPinA1      2                       // Quadrature encoder A pin
#define encodPinB1      8                       // Quadrature encoder B pin
#define M1              9                       // PWM outputs to motor driver module
#define M2              10

#define pulses_per_rotation     960


ros::NodeHandle  nh;

float pos = 0, vel= 0, output = 0, temp=0;
unsigned long lastTime,now,lasttimepub;
volatile long encoderPos = 0,last_pos=0;
std_msgs::Float32MultiArray joint_state;

void set_angle_cb( const std_msgs::Float32MultiArray& cmd_msg){
  output= cmd_msg.data[0]; 
}


ros::Subscriber<std_msgs::Float32MultiArray> sub("joints_to_aurdino", set_angle_cb);
ros::Publisher pub("joint_states_from_arduino", &joint_state);

void setup(){
  nh.initNode();
  nh.subscribe(sub);
  nh.advertise(pub);
  pinMode(encodPinA1, INPUT_PULLUP);                  // quadrature encoder input A
  pinMode(encodPinB1, INPUT_PULLUP);                  // quadrature encoder input B


#if 1
  attachInterrupt(0, encoder, FALLING);               // update encoder position
#endif
  TCCR1B = TCCR1B & 0b11111000 | 1;                   // set 31KHz PWM to prevent motor noise  
}

void loop(){
#if 1
#if 0
  encoderPos++;
  if (encoderPos > pulses_per_rotation || encoderPos < -pulses_per_rotation)
    encoderPos=0; 
#endif
  pos = (encoderPos*360)/pulses_per_rotation ;
  now = millis();
  int timeChange = (now - lastTime);
  if(timeChange>=500 )
  {
      temp = (360.0*1000*(encoderPos-last_pos)) /(pulses_per_rotation*(now - lastTime));
      if ((encoderPos < -2 || encoderPos > 2) && temp >= -60 && temp <=60 ) // to gaurd encoderPos at boundary i.e., after max limit it will rest. Then lastPos will be greater than encoderpos
          vel =temp;
      lastTime=now;
      last_pos=encoderPos;
  }
#if 0
  pwmOut(output);
#endif
  
  if ((now - lasttimepub)> 100)
  {
    joint_state.data_length=2;
    joint_state.data[0]=pos;
    joint_state.data[1]=vel;
    pub.publish(&joint_state);
    lasttimepub=now;
  }
#endif
  nh.spinOnce();
  delay(10);
}

void encoder()  {                                     // pulse and direction, direct port reading to save cycles

  if (encoderPos > pulses_per_rotation || encoderPos < -pulses_per_rotation)
    encoderPos=0; 
  if (PINB & 0b00000001)    encoderPos++;             // if(digitalRead(encodPinB1)==HIGH)   count ++;
  else                      encoderPos--;             // if(digitalRead(encodPinB1)==LOW)   count --;
}

void pwmOut(float out) {                                
  if (out > 0) {
    analogWrite(M2, out);                             // drive motor CW
    analogWrite(M1, 0);
  }
  else {
    analogWrite(M2, 0);
    analogWrite(M1, abs(out));                        // drive motor CCW
  }
}
